{"ast":null,"code":"import _asyncToGenerator from \"/Users/carolynwang/XYZGatorGit/CEN3031Proj/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { TestBed } from '@angular/core/testing';\nimport { By } from '@angular/platform-browser';\nimport { CardComponent } from './card.component';\nimport { RouterTestingModule } from '@angular/router/testing';\nimport { Router } from '@angular/router';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\ndescribe('CardComponent', () => {\n  let component;\n  let fixture;\n  let router;\n  beforeEach( /*#__PURE__*/_asyncToGenerator(function* () {\n    yield TestBed.configureTestingModule({\n      imports: [RouterTestingModule, HttpClientTestingModule],\n      declarations: [CardComponent]\n    }).compileComponents();\n    fixture = TestBed.createComponent(CardComponent);\n    component = fixture.componentInstance;\n    router = TestBed.inject(Router);\n    const navigateByUrlSpy = spyOn(router, 'navigateByUrl');\n    fixture.detectChanges();\n  }));\n  /*  checks that the component is created successfully by expecting the component object to be truthy. */\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n  /* checks that the cards are generated correctly by testing the length of the\n  component.cards array and ensuring that it has a length greater than 0 and exactly 28.\n  It then checks that each card in the component.cards array has the required properties:\n   id, isFlipped, isMatched, and color. */\n\n  it('should generate cards correctly', () => {\n    expect(component.cards.length).toBeGreaterThan(0);\n    expect(component.cards.length).toBe(28);\n\n    for (let i = 0; i < component.cards.length; i++) {\n      const card = component.cards[i];\n      expect(card.id).toBeDefined();\n      expect(card.isFlipped).toBeFalsy();\n      expect(card.isMatched).toBeFalsy();\n      expect(card.color).toBeDefined();\n    }\n  });\n  /* checks that a card flips over when it is clicked. It does this by selecting the first card\n  in the component.cards array, spying on the component.flipCard() method, clicking on the card\n  element in the fixture, and then expecting the component.flipCard() method to have been called\n  with the selected card as an argument. It then checks that the isFlipped property of the card\n  is set to true. */\n\n  it('should flip card when clicked', () => {\n    const card = component.cards[0];\n    spyOn(component, 'flipCard');\n    const cardElement = fixture.nativeElement.querySelector('.card');\n    cardElement.click();\n    expect(component.flipCard).toHaveBeenCalledWith(card);\n    expect(!card.isFlipped).toBeTruthy();\n  });\n  /* checks that the game correctly identifies matching cards.\n  It does this by selecting two cards from the component.cards array,\n  flipping them over, and then checking that the isMatched property of\n  each card is still false. */\n\n  it('should identify matching cards', () => {\n    const card1 = component.cards[0];\n    const card2 = component.cards[1];\n    component.flipCard(card1);\n    component.flipCard(card2);\n    expect(card1.isMatched).toBeTruthy();\n    expect(!card2.isMatched).toBeTruthy();\n  });\n  /* checks that unmatched cards are flipped back over when two cards are flipped\n  over that do not match. It does this by selecting two cards from the component.cards array,\n  flipping them over, and then checking that the isFlipped property of each card is still false. */\n\n  it('should flip unmatched cards back over', () => {\n    const card1 = component.cards[0];\n    const card2 = component.cards[2];\n    component.flipCard(card1);\n    component.flipCard(card2);\n    expect(!card1.isFlipped).toBeFalsy();\n    expect(!card2.isFlipped).toBeFalsy();\n  });\n  /* checks that the game can be reset by clicking the reset button. It does this by spying\n  on the component.reset() method, clicking on the reset button in the fixture, and then\n  checking that the component.reset() method has been called and that the disableCards property\n  of the component is false. */\n\n  it('should reset game', () => {\n    spyOn(component, 'reset');\n    const resetButton = fixture.nativeElement.querySelector('.reset button');\n    resetButton.click();\n    expect(component.reset).toHaveBeenCalled();\n    expect(component.disableCards).toBeFalsy();\n  });\n  /* checks that the game correctly matches cards with the same color. It does this by selecting\n   two cards from the component.cards array, setting their color property to 'red', triggering\n   a click event on each card element, and then checking that the flipped class has been added\n   to each card element and that the matched class has not been added. */\n\n  it('should match cards with the same color', () => {\n    const card1 = component.cards[0];\n    const card2 = component.cards[1];\n    card1.color = 'red';\n    card2.color = 'red';\n    fixture.detectChanges();\n    const cards = fixture.debugElement.queryAll(By.css('.card'));\n    expect(cards[0].nativeElement.classList.contains('flipped')).toBe(false);\n    expect(cards[1].nativeElement.classList.contains('flipped')).toBe(false);\n    cards[0].triggerEventHandler('click', null);\n    cards[1].triggerEventHandler('click', null);\n    fixture.detectChanges();\n    expect(cards[0].nativeElement.classList.contains('flipped')).toBe(true);\n    expect(cards[1].nativeElement.classList.contains('flipped')).toBe(true);\n    expect(cards[0].nativeElement.classList.contains('matched')).toBe(false);\n    expect(cards[1].nativeElement.classList.contains('matched')).toBe(false);\n  });\n});","map":{"version":3,"mappings":"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","names":["TestBed","By","CardComponent","RouterTestingModule","Router","HttpClientTestingModule","describe","component","fixture","router","beforeEach","configureTestingModule","imports","declarations","compileComponents","createComponent","componentInstance","inject","navigateByUrlSpy","spyOn","detectChanges","it","expect","toBeTruthy","cards","length","toBeGreaterThan","toBe","i","card","id","toBeDefined","isFlipped","toBeFalsy","isMatched","color","cardElement","nativeElement","querySelector","click","flipCard","toHaveBeenCalledWith","card1","card2","resetButton","reset","toHaveBeenCalled","disableCards","debugElement","queryAll","css","classList","contains","triggerEventHandler"],"sourceRoot":"","sources":["/Users/carolynwang/XYZGatorGit/CEN3031Proj/src/app/card/card.component.spec.ts"],"sourcesContent":["import { ComponentFixture, TestBed } from '@angular/core/testing';\nimport { By } from '@angular/platform-browser';\nimport { CardComponent } from './card.component';\nimport { RouterTestingModule } from '@angular/router/testing';\nimport { Router } from '@angular/router';\nimport { NgModule } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { HttpClientTestingModule } from '@angular/common/http/testing';\n\n\n\ndescribe('CardComponent', () => {\n  let component: CardComponent;\n  let fixture: ComponentFixture<CardComponent>;\n  let router: Router;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [RouterTestingModule, HttpClientTestingModule],\n      declarations: [ CardComponent ],\n    }).compileComponents();\n    fixture = TestBed.createComponent(CardComponent);\n    component = fixture.componentInstance;\n    router = TestBed.inject(Router);\n    const navigateByUrlSpy = spyOn(router, 'navigateByUrl');\n    fixture.detectChanges();\n  });\n  \n  /*  checks that the component is created successfully by expecting the component object to be truthy. */\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  /* checks that the cards are generated correctly by testing the length of the \n  component.cards array and ensuring that it has a length greater than 0 and exactly 28. \n  It then checks that each card in the component.cards array has the required properties:\n   id, isFlipped, isMatched, and color. */\n  it('should generate cards correctly', () => {\n    expect(component.cards.length).toBeGreaterThan(0);\n    expect(component.cards.length).toBe(28);\n    for (let i = 0; i < component.cards.length; i++) {\n      const card = component.cards[i];\n      expect(card.id).toBeDefined();\n      expect(card.isFlipped).toBeFalsy();\n      expect(card.isMatched).toBeFalsy();\n      expect(card.color).toBeDefined();\n    }\n  });\n\n  /* checks that a card flips over when it is clicked. It does this by selecting the first card \n  in the component.cards array, spying on the component.flipCard() method, clicking on the card \n  element in the fixture, and then expecting the component.flipCard() method to have been called \n  with the selected card as an argument. It then checks that the isFlipped property of the card \n  is set to true. */\n  it('should flip card when clicked', () => {\n    const card = component.cards[0];\n    spyOn(component, 'flipCard');\n    const cardElement = fixture.nativeElement.querySelector('.card');\n    cardElement.click();\n    expect(component.flipCard).toHaveBeenCalledWith(card);\n    expect(!card.isFlipped).toBeTruthy();\n  });\n\n  /* checks that the game correctly identifies matching cards. \n  It does this by selecting two cards from the component.cards array, \n  flipping them over, and then checking that the isMatched property of \n  each card is still false. */\n  it('should identify matching cards', () => {\n    const card1 = component.cards[0];\n    const card2 = component.cards[1];\n    component.flipCard(card1);\n    component.flipCard(card2);\n    expect(card1.isMatched).toBeTruthy();\n    expect(!card2.isMatched).toBeTruthy();\n  });\n\n  /* checks that unmatched cards are flipped back over when two cards are flipped \n  over that do not match. It does this by selecting two cards from the component.cards array, \n  flipping them over, and then checking that the isFlipped property of each card is still false. */\n  it('should flip unmatched cards back over', () => {\n    const card1 = component.cards[0];\n    const card2 = component.cards[2];\n    component.flipCard(card1);\n    component.flipCard(card2);\n    expect(!card1.isFlipped).toBeFalsy();\n    expect(!card2.isFlipped).toBeFalsy();\n  });\n\n  /* checks that the game can be reset by clicking the reset button. It does this by spying \n  on the component.reset() method, clicking on the reset button in the fixture, and then \n  checking that the component.reset() method has been called and that the disableCards property \n  of the component is false. */\n  it('should reset game', () => {\n    spyOn(component, 'reset');\n    const resetButton = fixture.nativeElement.querySelector('.reset button');\n    resetButton.click();\n    expect(component.reset).toHaveBeenCalled();\n    expect(component.disableCards).toBeFalsy();\n  });\n\n  /* checks that the game correctly matches cards with the same color. It does this by selecting\n   two cards from the component.cards array, setting their color property to 'red', triggering \n   a click event on each card element, and then checking that the flipped class has been added \n   to each card element and that the matched class has not been added. */\n  it('should match cards with the same color', () => {\n    const card1 = component.cards[0];\n    const card2 = component.cards[1];\n    card1.color = 'red';\n    card2.color = 'red';\n    fixture.detectChanges();\n    const cards = fixture.debugElement.queryAll(By.css('.card'));\n    expect(cards[0].nativeElement.classList.contains('flipped')).toBe(false);\n    expect(cards[1].nativeElement.classList.contains('flipped')).toBe(false);\n    cards[0].triggerEventHandler('click', null);\n    cards[1].triggerEventHandler('click', null);\n    fixture.detectChanges();\n    expect(cards[0].nativeElement.classList.contains('flipped')).toBe(true);\n    expect(cards[1].nativeElement.classList.contains('flipped')).toBe(true);\n    expect(cards[0].nativeElement.classList.contains('matched')).toBe(false);\n    expect(cards[1].nativeElement.classList.contains('matched')).toBe(false);\n  });\n\n\n\n})"]},"metadata":{},"sourceType":"module"}