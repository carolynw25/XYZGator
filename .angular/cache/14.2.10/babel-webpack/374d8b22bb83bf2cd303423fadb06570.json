{"ast":null,"code":"'use strict';\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n(function (factory) {\n  typeof define === 'function' && define.amd ? define(factory) : factory();\n})(function () {\n  'use strict';\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  Zone.__load_patch('jasmine', function (global, Zone, api) {\n    var __extends = function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n\n      function __() {\n        this.constructor = d;\n      }\n\n      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    }; // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n    // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n\n\n    if (!Zone) throw new Error('Missing: zone.js');\n\n    if (typeof jest !== 'undefined') {\n      // return if jasmine is a light implementation inside jest\n      // in this case, we are running inside jest not jasmine\n      return;\n    }\n\n    if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n      return;\n    }\n\n    jasmine['__zone_patch__'] = true;\n    var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n    var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n    if (!SyncTestZoneSpec) throw new Error('Missing: SyncTestZoneSpec');\n    if (!ProxyZoneSpec) throw new Error('Missing: ProxyZoneSpec');\n    var ambientZone = Zone.current;\n    var symbol = Zone.__symbol__; // whether patch jasmine clock when in fakeAsync\n\n    var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true; // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n    // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n    // automatically disable the auto jump into fakeAsync feature\n\n    var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock && (global[symbol('fakeAsyncPatchLock')] === true || global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true);\n    var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n\n    if (!ignoreUnhandledRejection) {\n      var globalErrors_1 = jasmine.GlobalErrors;\n\n      if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n        jasmine[symbol('GlobalErrors')] = globalErrors_1;\n\n        jasmine.GlobalErrors = function () {\n          var instance = new globalErrors_1();\n          var originalInstall = instance.install;\n\n          if (originalInstall && !instance[symbol('install')]) {\n            instance[symbol('install')] = originalInstall;\n\n            instance.install = function () {\n              var isNode = typeof process !== 'undefined' && !!process.on; // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,\n              // it installs the browser rejection handler through the `global.addEventListener`.\n              // This code may be run in the browser environment where `process` is not defined, and\n              // this will lead to a runtime exception since Webpack 5 removed automatic Node.js\n              // polyfills. Note, that events are named differently, it's `unhandledRejection` in\n              // Node.js and `unhandledrejection` in the browser.\n\n              var originalHandlers = isNode ? process.listeners('unhandledRejection') : global.eventListeners('unhandledrejection');\n              var result = originalInstall.apply(this, arguments);\n              isNode ? process.removeAllListeners('unhandledRejection') : global.removeAllListeners('unhandledrejection');\n\n              if (originalHandlers) {\n                originalHandlers.forEach(function (handler) {\n                  if (isNode) {\n                    process.on('unhandledRejection', handler);\n                  } else {\n                    global.addEventListener('unhandledrejection', handler);\n                  }\n                });\n              }\n\n              return result;\n            };\n          }\n\n          return instance;\n        };\n      }\n    } // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n\n\n    var jasmineEnv = jasmine.getEnv();\n    ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n\n      jasmineEnv[methodName] = function (description, specDefinitions) {\n        return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n      };\n    });\n    ['it', 'xit', 'fit'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n        arguments[1] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n    ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n      var originalJasmineFn = jasmineEnv[methodName];\n      jasmineEnv[symbol(methodName)] = originalJasmineFn;\n\n      jasmineEnv[methodName] = function (specDefinitions, timeout) {\n        arguments[0] = wrapTestInZone(specDefinitions);\n        return originalJasmineFn.apply(this, arguments);\n      };\n    });\n\n    if (!disablePatchingJasmineClock) {\n      // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n      // they can work properly in FakeAsyncTest\n      var originalClockFn_1 = jasmine[symbol('clock')] = jasmine['clock'];\n\n      jasmine['clock'] = function () {\n        var clock = originalClockFn_1.apply(this, arguments);\n\n        if (!clock[symbol('patched')]) {\n          clock[symbol('patched')] = symbol('patched');\n          var originalTick_1 = clock[symbol('tick')] = clock.tick;\n\n          clock.tick = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n            }\n\n            return originalTick_1.apply(this, arguments);\n          };\n\n          var originalMockDate_1 = clock[symbol('mockDate')] = clock.mockDate;\n\n          clock.mockDate = function () {\n            var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n\n            if (fakeAsyncZoneSpec) {\n              var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n              return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] : arguments);\n            }\n\n            return originalMockDate_1.apply(this, arguments);\n          }; // for auto go into fakeAsync feature, we need the flag to enable it\n\n\n          if (enableAutoFakeAsyncWhenClockPatched) {\n            ['install', 'uninstall'].forEach(function (methodName) {\n              var originalClockFn = clock[symbol(methodName)] = clock[methodName];\n\n              clock[methodName] = function () {\n                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n\n                if (FakeAsyncTestZoneSpec) {\n                  jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                  return;\n                }\n\n                return originalClockFn.apply(this, arguments);\n              };\n            });\n          }\n        }\n\n        return clock;\n      };\n    } // monkey patch createSpyObj to make properties enumerable to true\n\n\n    if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n      var originalCreateSpyObj_1 = jasmine.createSpyObj;\n      jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n\n      jasmine.createSpyObj = function () {\n        var args = Array.prototype.slice.call(arguments);\n        var propertyNames = args.length >= 3 ? args[2] : null;\n        var spyObj;\n\n        if (propertyNames) {\n          var defineProperty_1 = Object.defineProperty;\n\n          Object.defineProperty = function (obj, p, attributes) {\n            return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), {\n              configurable: true,\n              enumerable: true\n            }));\n          };\n\n          try {\n            spyObj = originalCreateSpyObj_1.apply(this, args);\n          } finally {\n            Object.defineProperty = defineProperty_1;\n          }\n        } else {\n          spyObj = originalCreateSpyObj_1.apply(this, args);\n        }\n\n        return spyObj;\n      };\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n     * synchronous-only zone.\n     */\n\n\n    function wrapDescribeInZone(description, describeBody) {\n      return function () {\n        // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n        // error if any asynchronous operations are attempted inside of a `describe`.\n        var syncZone = ambientZone.fork(new SyncTestZoneSpec(\"jasmine.describe#\".concat(description)));\n        return syncZone.run(describeBody, this, arguments);\n      };\n    }\n\n    function runInTestZone(testBody, applyThis, queueRunner, done) {\n      var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n      queueRunner.testProxyZoneSpec;\n      var testProxyZone = queueRunner.testProxyZone;\n\n      if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n        // auto run a fakeAsync\n        var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n\n        if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n          testBody = fakeAsyncModule.fakeAsync(testBody);\n        }\n      }\n\n      if (done) {\n        return testProxyZone.run(testBody, applyThis, [done]);\n      } else {\n        return testProxyZone.run(testBody, applyThis);\n      }\n    }\n    /**\n     * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n     * execute in a ProxyZone zone.\n     * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n     */\n\n\n    function wrapTestInZone(testBody) {\n      // The `done` callback is only passed through if the function expects at least one argument.\n      // Note we have to make a function with correct number of arguments, otherwise jasmine will\n      // think that all functions are sync or async.\n      return testBody && (testBody.length ? function (done) {\n        return runInTestZone(testBody, this, this.queueRunner, done);\n      } : function () {\n        return runInTestZone(testBody, this, this.queueRunner);\n      });\n    }\n\n    var QueueRunner = jasmine.QueueRunner;\n\n    jasmine.QueueRunner = function (_super) {\n      __extends(ZoneQueueRunner, _super);\n\n      function ZoneQueueRunner(attrs) {\n        var _this = this;\n\n        if (attrs.onComplete) {\n          attrs.onComplete = function (fn) {\n            return function () {\n              // All functions are done, clear the test zone.\n              _this.testProxyZone = null;\n              _this.testProxyZoneSpec = null;\n              ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n            };\n          }(attrs.onComplete);\n        }\n\n        var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n\n        var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n\n        if (nativeSetTimeout) {\n          // should run setTimeout inside jasmine outside of zone\n          attrs.timeout = {\n            setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n            clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n          };\n        } // create a userContext to hold the queueRunner itself\n        // so we can access the testProxy in it/xit/beforeEach ...\n\n\n        if (jasmine.UserContext) {\n          if (!attrs.userContext) {\n            attrs.userContext = new jasmine.UserContext();\n          }\n\n          attrs.userContext.queueRunner = this;\n        } else {\n          if (!attrs.userContext) {\n            attrs.userContext = {};\n          }\n\n          attrs.userContext.queueRunner = this;\n        } // patch attrs.onException\n\n\n        var onException = attrs.onException;\n\n        attrs.onException = function (error) {\n          if (error && error.message === 'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n            // jasmine timeout, we can make the error message more\n            // reasonable to tell what tasks are pending\n            var proxyZoneSpec = this && this.testProxyZoneSpec;\n\n            if (proxyZoneSpec) {\n              var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n\n              try {\n                // try catch here in case error.message is not writable\n                error.message += pendingTasksInfo;\n              } catch (err) {}\n            }\n          }\n\n          if (onException) {\n            onException.call(this, error);\n          }\n        };\n\n        _super.call(this, attrs);\n      }\n\n      ZoneQueueRunner.prototype.execute = function () {\n        var _this = this;\n\n        var zone = Zone.current;\n        var isChildOfAmbientZone = false;\n\n        while (zone) {\n          if (zone === ambientZone) {\n            isChildOfAmbientZone = true;\n            break;\n          }\n\n          zone = zone.parent;\n        }\n\n        if (!isChildOfAmbientZone) throw new Error('Unexpected Zone: ' + Zone.current.name); // This is the zone which will be used for running individual tests.\n        // It will be a proxy zone, so that the tests function can retroactively install\n        // different zones.\n        // Example:\n        //   - In beforeEach() do childZone = Zone.current.fork(...);\n        //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n        //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n        //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n        //     fakeAsync behavior to the childZone.\n\n        this.testProxyZoneSpec = new ProxyZoneSpec();\n        this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n\n        if (!Zone.currentTask) {\n          // if we are not running in a task then if someone would register a\n          // element.addEventListener and then calling element.click() the\n          // addEventListener callback would think that it is the top most task and would\n          // drain the microtask queue on element.click() which would be incorrect.\n          // For this reason we always force a task when running jasmine tests.\n          Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () {\n            return QueueRunner.prototype.execute.call(_this);\n          });\n        } else {\n          _super.prototype.execute.call(this);\n        }\n      };\n\n      return ZoneQueueRunner;\n    }(QueueRunner);\n  });\n});","map":{"version":3,"names":["factory","define","amd","Zone","__load_patch","global","api","__extends","d","b","p","hasOwnProperty","__","constructor","prototype","Object","create","Error","jest","jasmine","SyncTestZoneSpec","ProxyZoneSpec","ambientZone","current","symbol","__symbol__","disablePatchingJasmineClock","enableAutoFakeAsyncWhenClockPatched","ignoreUnhandledRejection","globalErrors_1","GlobalErrors","instance","originalInstall","install","isNode","process","on","originalHandlers","listeners","eventListeners","result","apply","arguments","removeAllListeners","forEach","handler","addEventListener","jasmineEnv","getEnv","methodName","originalJasmineFn","description","specDefinitions","call","wrapDescribeInZone","timeout","wrapTestInZone","originalClockFn_1","clock","originalTick_1","tick","fakeAsyncZoneSpec","get","originalMockDate_1","mockDate","dateTime","length","Date","setFakeBaseSystemTime","getTime","originalClockFn","FakeAsyncTestZoneSpec","originalCreateSpyObj_1","createSpyObj","args","Array","slice","propertyNames","spyObj","defineProperty_1","defineProperty","obj","attributes","assign","configurable","enumerable","describeBody","syncZone","fork","concat","run","runInTestZone","testBody","applyThis","queueRunner","done","isClockInstalled","testProxyZoneSpec","testProxyZone","fakeAsyncModule","fakeAsync","QueueRunner","_super","ZoneQueueRunner","attrs","_this","onComplete","fn","scheduleMicroTask","nativeSetTimeout","nativeClearTimeout","setTimeout","clearTimeout","UserContext","userContext","onException","error","message","proxyZoneSpec","pendingTasksInfo","getAndClearPendingTasksInfo","err","execute","zone","isChildOfAmbientZone","parent","name","currentTask"],"sources":["/Users/dantasbradley/Documents/GitHub/CEN3031Proj/node_modules/zone.js/dist/jasmine-patch.js"],"sourcesContent":["'use strict';\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n(function (factory) {\n    typeof define === 'function' && define.amd ? define(factory) :\n        factory();\n})((function () {\n    'use strict';\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    Zone.__load_patch('jasmine', function (global, Zone, api) {\n        var __extends = function (d, b) {\n            for (var p in b)\n                if (b.hasOwnProperty(p))\n                    d[p] = b[p];\n            function __() {\n                this.constructor = d;\n            }\n            d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());\n        };\n        // Patch jasmine's describe/it/beforeEach/afterEach functions so test code always runs\n        // in a testZone (ProxyZone). (See: angular/zone.js#91 & angular/angular#10503)\n        if (!Zone)\n            throw new Error('Missing: zone.js');\n        if (typeof jest !== 'undefined') {\n            // return if jasmine is a light implementation inside jest\n            // in this case, we are running inside jest not jasmine\n            return;\n        }\n        if (typeof jasmine == 'undefined' || jasmine['__zone_patch__']) {\n            return;\n        }\n        jasmine['__zone_patch__'] = true;\n        var SyncTestZoneSpec = Zone['SyncTestZoneSpec'];\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (!SyncTestZoneSpec)\n            throw new Error('Missing: SyncTestZoneSpec');\n        if (!ProxyZoneSpec)\n            throw new Error('Missing: ProxyZoneSpec');\n        var ambientZone = Zone.current;\n        var symbol = Zone.__symbol__;\n        // whether patch jasmine clock when in fakeAsync\n        var disablePatchingJasmineClock = global[symbol('fakeAsyncDisablePatchingClock')] === true;\n        // the original variable name fakeAsyncPatchLock is not accurate, so the name will be\n        // fakeAsyncAutoFakeAsyncWhenClockPatched and if this enablePatchingJasmineClock is false, we also\n        // automatically disable the auto jump into fakeAsync feature\n        var enableAutoFakeAsyncWhenClockPatched = !disablePatchingJasmineClock &&\n            ((global[symbol('fakeAsyncPatchLock')] === true) ||\n                (global[symbol('fakeAsyncAutoFakeAsyncWhenClockPatched')] === true));\n        var ignoreUnhandledRejection = global[symbol('ignoreUnhandledRejection')] === true;\n        if (!ignoreUnhandledRejection) {\n            var globalErrors_1 = jasmine.GlobalErrors;\n            if (globalErrors_1 && !jasmine[symbol('GlobalErrors')]) {\n                jasmine[symbol('GlobalErrors')] = globalErrors_1;\n                jasmine.GlobalErrors = function () {\n                    var instance = new globalErrors_1();\n                    var originalInstall = instance.install;\n                    if (originalInstall && !instance[symbol('install')]) {\n                        instance[symbol('install')] = originalInstall;\n                        instance.install = function () {\n                            var isNode = typeof process !== 'undefined' && !!process.on;\n                            // Note: Jasmine checks internally if `process` and `process.on` is defined. Otherwise,\n                            // it installs the browser rejection handler through the `global.addEventListener`.\n                            // This code may be run in the browser environment where `process` is not defined, and\n                            // this will lead to a runtime exception since Webpack 5 removed automatic Node.js\n                            // polyfills. Note, that events are named differently, it's `unhandledRejection` in\n                            // Node.js and `unhandledrejection` in the browser.\n                            var originalHandlers = isNode ? process.listeners('unhandledRejection') :\n                                global.eventListeners('unhandledrejection');\n                            var result = originalInstall.apply(this, arguments);\n                            isNode ? process.removeAllListeners('unhandledRejection') :\n                                global.removeAllListeners('unhandledrejection');\n                            if (originalHandlers) {\n                                originalHandlers.forEach(function (handler) {\n                                    if (isNode) {\n                                        process.on('unhandledRejection', handler);\n                                    }\n                                    else {\n                                        global.addEventListener('unhandledrejection', handler);\n                                    }\n                                });\n                            }\n                            return result;\n                        };\n                    }\n                    return instance;\n                };\n            }\n        }\n        // Monkey patch all of the jasmine DSL so that each function runs in appropriate zone.\n        var jasmineEnv = jasmine.getEnv();\n        ['describe', 'xdescribe', 'fdescribe'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[methodName] = function (description, specDefinitions) {\n                return originalJasmineFn.call(this, description, wrapDescribeInZone(description, specDefinitions));\n            };\n        });\n        ['it', 'xit', 'fit'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (description, specDefinitions, timeout) {\n                arguments[1] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        ['beforeEach', 'afterEach', 'beforeAll', 'afterAll'].forEach(function (methodName) {\n            var originalJasmineFn = jasmineEnv[methodName];\n            jasmineEnv[symbol(methodName)] = originalJasmineFn;\n            jasmineEnv[methodName] = function (specDefinitions, timeout) {\n                arguments[0] = wrapTestInZone(specDefinitions);\n                return originalJasmineFn.apply(this, arguments);\n            };\n        });\n        if (!disablePatchingJasmineClock) {\n            // need to patch jasmine.clock().mockDate and jasmine.clock().tick() so\n            // they can work properly in FakeAsyncTest\n            var originalClockFn_1 = (jasmine[symbol('clock')] = jasmine['clock']);\n            jasmine['clock'] = function () {\n                var clock = originalClockFn_1.apply(this, arguments);\n                if (!clock[symbol('patched')]) {\n                    clock[symbol('patched')] = symbol('patched');\n                    var originalTick_1 = (clock[symbol('tick')] = clock.tick);\n                    clock.tick = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            return fakeAsyncZoneSpec.tick.apply(fakeAsyncZoneSpec, arguments);\n                        }\n                        return originalTick_1.apply(this, arguments);\n                    };\n                    var originalMockDate_1 = (clock[symbol('mockDate')] = clock.mockDate);\n                    clock.mockDate = function () {\n                        var fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n                        if (fakeAsyncZoneSpec) {\n                            var dateTime = arguments.length > 0 ? arguments[0] : new Date();\n                            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(fakeAsyncZoneSpec, dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                arguments);\n                        }\n                        return originalMockDate_1.apply(this, arguments);\n                    };\n                    // for auto go into fakeAsync feature, we need the flag to enable it\n                    if (enableAutoFakeAsyncWhenClockPatched) {\n                        ['install', 'uninstall'].forEach(function (methodName) {\n                            var originalClockFn = (clock[symbol(methodName)] = clock[methodName]);\n                            clock[methodName] = function () {\n                                var FakeAsyncTestZoneSpec = Zone['FakeAsyncTestZoneSpec'];\n                                if (FakeAsyncTestZoneSpec) {\n                                    jasmine[symbol('clockInstalled')] = 'install' === methodName;\n                                    return;\n                                }\n                                return originalClockFn.apply(this, arguments);\n                            };\n                        });\n                    }\n                }\n                return clock;\n            };\n        }\n        // monkey patch createSpyObj to make properties enumerable to true\n        if (!jasmine[Zone.__symbol__('createSpyObj')]) {\n            var originalCreateSpyObj_1 = jasmine.createSpyObj;\n            jasmine[Zone.__symbol__('createSpyObj')] = originalCreateSpyObj_1;\n            jasmine.createSpyObj = function () {\n                var args = Array.prototype.slice.call(arguments);\n                var propertyNames = args.length >= 3 ? args[2] : null;\n                var spyObj;\n                if (propertyNames) {\n                    var defineProperty_1 = Object.defineProperty;\n                    Object.defineProperty = function (obj, p, attributes) {\n                        return defineProperty_1.call(this, obj, p, Object.assign(Object.assign({}, attributes), { configurable: true, enumerable: true }));\n                    };\n                    try {\n                        spyObj = originalCreateSpyObj_1.apply(this, args);\n                    }\n                    finally {\n                        Object.defineProperty = defineProperty_1;\n                    }\n                }\n                else {\n                    spyObj = originalCreateSpyObj_1.apply(this, args);\n                }\n                return spyObj;\n            };\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `describe` block to execute in a\n         * synchronous-only zone.\n         */\n        function wrapDescribeInZone(description, describeBody) {\n            return function () {\n                // Create a synchronous-only zone in which to run `describe` blocks in order to raise an\n                // error if any asynchronous operations are attempted inside of a `describe`.\n                var syncZone = ambientZone.fork(new SyncTestZoneSpec(\"jasmine.describe#\".concat(description)));\n                return syncZone.run(describeBody, this, arguments);\n            };\n        }\n        function runInTestZone(testBody, applyThis, queueRunner, done) {\n            var isClockInstalled = !!jasmine[symbol('clockInstalled')];\n            queueRunner.testProxyZoneSpec;\n            var testProxyZone = queueRunner.testProxyZone;\n            if (isClockInstalled && enableAutoFakeAsyncWhenClockPatched) {\n                // auto run a fakeAsync\n                var fakeAsyncModule = Zone[Zone.__symbol__('fakeAsyncTest')];\n                if (fakeAsyncModule && typeof fakeAsyncModule.fakeAsync === 'function') {\n                    testBody = fakeAsyncModule.fakeAsync(testBody);\n                }\n            }\n            if (done) {\n                return testProxyZone.run(testBody, applyThis, [done]);\n            }\n            else {\n                return testProxyZone.run(testBody, applyThis);\n            }\n        }\n        /**\n         * Gets a function wrapping the body of a Jasmine `it/beforeEach/afterEach` block to\n         * execute in a ProxyZone zone.\n         * This will run in `testProxyZone`. The `testProxyZone` will be reset by the `ZoneQueueRunner`\n         */\n        function wrapTestInZone(testBody) {\n            // The `done` callback is only passed through if the function expects at least one argument.\n            // Note we have to make a function with correct number of arguments, otherwise jasmine will\n            // think that all functions are sync or async.\n            return (testBody && (testBody.length ? function (done) {\n                return runInTestZone(testBody, this, this.queueRunner, done);\n            } : function () {\n                return runInTestZone(testBody, this, this.queueRunner);\n            }));\n        }\n        var QueueRunner = jasmine.QueueRunner;\n        jasmine.QueueRunner = (function (_super) {\n            __extends(ZoneQueueRunner, _super);\n            function ZoneQueueRunner(attrs) {\n                var _this = this;\n                if (attrs.onComplete) {\n                    attrs.onComplete = (function (fn) { return function () {\n                        // All functions are done, clear the test zone.\n                        _this.testProxyZone = null;\n                        _this.testProxyZoneSpec = null;\n                        ambientZone.scheduleMicroTask('jasmine.onComplete', fn);\n                    }; })(attrs.onComplete);\n                }\n                var nativeSetTimeout = global[Zone.__symbol__('setTimeout')];\n                var nativeClearTimeout = global[Zone.__symbol__('clearTimeout')];\n                if (nativeSetTimeout) {\n                    // should run setTimeout inside jasmine outside of zone\n                    attrs.timeout = {\n                        setTimeout: nativeSetTimeout ? nativeSetTimeout : global.setTimeout,\n                        clearTimeout: nativeClearTimeout ? nativeClearTimeout : global.clearTimeout\n                    };\n                }\n                // create a userContext to hold the queueRunner itself\n                // so we can access the testProxy in it/xit/beforeEach ...\n                if (jasmine.UserContext) {\n                    if (!attrs.userContext) {\n                        attrs.userContext = new jasmine.UserContext();\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                else {\n                    if (!attrs.userContext) {\n                        attrs.userContext = {};\n                    }\n                    attrs.userContext.queueRunner = this;\n                }\n                // patch attrs.onException\n                var onException = attrs.onException;\n                attrs.onException = function (error) {\n                    if (error &&\n                        error.message ===\n                            'Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.') {\n                        // jasmine timeout, we can make the error message more\n                        // reasonable to tell what tasks are pending\n                        var proxyZoneSpec = this && this.testProxyZoneSpec;\n                        if (proxyZoneSpec) {\n                            var pendingTasksInfo = proxyZoneSpec.getAndClearPendingTasksInfo();\n                            try {\n                                // try catch here in case error.message is not writable\n                                error.message += pendingTasksInfo;\n                            }\n                            catch (err) {\n                            }\n                        }\n                    }\n                    if (onException) {\n                        onException.call(this, error);\n                    }\n                };\n                _super.call(this, attrs);\n            }\n            ZoneQueueRunner.prototype.execute = function () {\n                var _this = this;\n                var zone = Zone.current;\n                var isChildOfAmbientZone = false;\n                while (zone) {\n                    if (zone === ambientZone) {\n                        isChildOfAmbientZone = true;\n                        break;\n                    }\n                    zone = zone.parent;\n                }\n                if (!isChildOfAmbientZone)\n                    throw new Error('Unexpected Zone: ' + Zone.current.name);\n                // This is the zone which will be used for running individual tests.\n                // It will be a proxy zone, so that the tests function can retroactively install\n                // different zones.\n                // Example:\n                //   - In beforeEach() do childZone = Zone.current.fork(...);\n                //   - In it() try to do fakeAsync(). The issue is that because the beforeEach forked the\n                //     zone outside of fakeAsync it will be able to escape the fakeAsync rules.\n                //   - Because ProxyZone is parent fo `childZone` fakeAsync can retroactively add\n                //     fakeAsync behavior to the childZone.\n                this.testProxyZoneSpec = new ProxyZoneSpec();\n                this.testProxyZone = ambientZone.fork(this.testProxyZoneSpec);\n                if (!Zone.currentTask) {\n                    // if we are not running in a task then if someone would register a\n                    // element.addEventListener and then calling element.click() the\n                    // addEventListener callback would think that it is the top most task and would\n                    // drain the microtask queue on element.click() which would be incorrect.\n                    // For this reason we always force a task when running jasmine tests.\n                    Zone.current.scheduleMicroTask('jasmine.execute().forceTask', function () { return QueueRunner.prototype.execute.call(_this); });\n                }\n                else {\n                    _super.prototype.execute.call(this);\n                }\n            };\n            return ZoneQueueRunner;\n        })(QueueRunner);\n    });\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}